/*

Expected usage:

./regression-runner <target> <cppfront_exe_path> <tests_path_or_single_test>
                    <compiler_path> <include_path> <compiler_flags...>

*/
#define LAUNCH_PROGRAM_IMPLEMENTATION
#include "launch_program.hpp"

fs: namespace == std::filesystem;

main: (args) -> int = {
	min_args :== 5;
	assert(
		args.ssize()-1 >= min_args,
		"Expected at least (min_args)$ arguments. Received (args.ssize()-1)$\n",
	);

	// this_exe_path := fs::path(args[0]).canonical();
	ctx: testing_context = (
		args[1],
		fs::path(args[2]).canonical(),
		fs::path(args[4]), // We trust that this exe is in PATH.
		fs::path(args[5]).canonical(),
	);
	path_to_test := fs::path(args[3]).canonical();
	(copy i := min_args + 1) while i < args.ssize() next i++ {
		_ = ctx.unformatted_compiler_args.emplace_back(args[i]);
	}

	// TODO: Remove this and all other debug prints (grep std::cout)
	std::cout << "ctx.target: (ctx.target)$\n";
	std::cout << "ctx.cppfront: (ctx.cppfront.string())$\n";
	std::cout << "path_to_test: (path_to_test.string())$\n";
	std::cout << "ctx.compiler: (ctx.compiler.string())$\n";
	std::cout << "ctx.include_dir: (ctx.include_dir.string())$\n";
	std::cout << "ctx.unformatted_compiler_args: (ctx.unformatted_compiler_args)$\n";
	std::cout << '\n';

	assert(
		ctx.cppfront.is_regular_file(),
		"Path to cppfront executable must be a regular file\n",
	);

	ext :== ".cpp2";

	exit_status := EXIT_SUCCESS;
	if !path_to_test.is_directory() {
		assert(
			path_to_test.extension() == ext,
			"For one-shot testing, the path must point to a (ext)$ file\n",
		);
		tr := test_one(ctx, path_to_test);
		std::cout << "(path_to_test.filename())$: (tr.to_string())$\n";
		if tr != test_result::ok { exit_status = EXIT_FAILURE; }
	} else {
		for : fs::directory_iterator = (path_to_test) do (entry)
		if entry.path().extension() == ext {
			tr := test_one(ctx, entry.path());
			std::cout << "(entry.path().filename())$: (tr.to_string())$\n";
			if tr != test_result::ok { exit_status = EXIT_FAILURE; }
		}
	}

	return exit_status;
}

testing_context: @struct type = {
	target: std::string_view;
	cppfront: fs::path;
	compiler: fs::path;
	include_dir: fs::path;
	unformatted_compiler_args: std::vector<std::string_view> = ();
	// override_files: bool; // TODO
}

test_result: @enum type = {
	fail_unknown;
	first_run;
	lowered_output_mismatch;
	cppfront_output_mismatch;
	compiler_output_mismatch;
	compiler_output_exists_when_it_shouldnt;
	test_exe_output_mismatch;
	test_exe_output_exists_when_it_shouldnt;
	ok;

	is_first_run: (this) -> bool = this == first_run;
}

test_one: (
	ctx: testing_context,
	test_filepath: fs::path,
) -> test_result = {
	ins: testing_instance = (
		test_filepath,
		test_filepath.parent_path() / "results" / test_filepath.stem(),
		fs::temp_directory_path() / "cppfront-regressions" / test_filepath.stem(),
		nullptr,
	);

	if !ins.result_dir.exists() || ins.result_dir.is_empty() {
		ins.result = test_result::first_run;
		_ = ins.result_dir.create_directory();
		ins.output_dir = ins.result_dir&;
	} else {
		ins.output_dir = ins.work_dir&;
	}
	assert(
		ins.result_dir.is_directory(),
		"The result path ((ins.result_dir)$) must be a directory\n",
	);
	assert(ins.output_dir != nullptr);

	_ = ins.work_dir.create_directories();
	_: finally = ( :() = { _ = ins.work_dir&$*.remove_all(); } );

	source_fn := transpile(ctx, ins);
	if source_fn.empty() { return ins.result; }

	executable_filepath := compile(ctx, ins, source_fn);
	if executable_filepath.empty() { return ins.result; }

	if execute(ins, executable_filepath) && !ins.result.is_first_run() {
		ins.result = test_result::ok;
	}

	return ins.result;
}

testing_instance: @struct type = {
	test_filepath: fs::path;
	result_dir: fs::path;
	work_dir: fs::path;
	output_dir: *const fs::path;
	result: test_result = ();
}

transpile: (ctx: testing_context, inout ins: testing_instance) -> fs::path = {
	lowered_output_fn :== "00-lowered.cpp";
	lowered_output_filepath: const = ins.output_dir* / lowered_output_fn;

	cppfront_args: std::vector<std::string> = (
		"-o",
		lowered_output_filepath.string(),
		ins.test_filepath.filename().string(),
	);

	launch_result := launch_program(
		ins.test_filepath.parent_path(),
		ctx.cppfront,
		cppfront_args,
	);

	cppfront_output_fn :== "01-cppfront.output";
	cppfront_output_filepath: const = ins.output_dir* / cppfront_output_fn;

	(: std::ofstream = (cppfront_output_filepath)) << launch_result.output;

	if ins.result.is_first_run() {
		if lowered_output_filepath.exists() {
			return lowered_output_filepath.filename();
		} else {
			return ();
		}
	}

	assert(ins.output_dir* != ins.result_dir);

	if (ins.result_dir / lowered_output_fn).read_file() !=
	                lowered_output_filepath.read_file() {
		ins.result = test_result::lowered_output_mismatch;
		return ();
	}

	if (ins.result_dir / cppfront_output_fn).read_file() !=
	                cppfront_output_filepath.read_file() {
		return ();
	}

	if lowered_output_filepath.exists() {
		return lowered_output_filepath.filename();
	} else {
		if !ins.result.is_first_run() { ins.result = test_result::ok; }
		return ();
	}
}

compile: (ctx: testing_context, inout ins: testing_instance, source_fn: fs::path) -> fs::path = {
	compiler_exe_out_path: const = ins.work_dir / "test.exe";

	// NOTE: We always want this to be run with result's path so compiler
	// error output matches.
	source_file: const = ins.result_dir / source_fn;

	compiler_args: std::vector<std::string> = ();
	for ctx.unformatted_compiler_args do (uarg) {
		arg := compiler_args.emplace_back(uarg)&;
		arg*.replace_all("{source_file}", source_file.string());
		arg*.replace_all("{include_dir}", ctx.include_dir.string());
		arg*.replace_all("{exe_out}", compiler_exe_out_path.string());
	}
	// std::cout << "compiler_args: (compiler_args)$\n";

	launch_result := launch_program(
		ins.work_dir,
		ctx.compiler,
		compiler_args,
	);

	compiler_output_fn: const = "02-(ctx.target)$-compiler.output";
	compiler_output_filepath: const = ins.output_dir* / compiler_output_fn;

	if !launch_result.output.empty() {
		(: std::ofstream = (compiler_output_filepath)) << launch_result.output;
	}

	if ins.result.is_first_run() {
		if compiler_exe_out_path.exists() {
			return compiler_exe_out_path;
		} else {
			return ();
		}
	}

	if !launch_result.output.empty() {
		assert(ins.output_dir* != ins.result_dir);

		if (ins.result_dir / compiler_output_fn).read_file() !=
		                compiler_output_filepath.read_file() {
			ins.result = test_result::compiler_output_mismatch;
			return ();
		}
	} else {
		if compiler_output_filepath.exists() {
			ins.result = test_result::compiler_output_exists_when_it_shouldnt;
			return ();
		}
	}

	if compiler_exe_out_path.exists() {
		return compiler_exe_out_path;
	} else {
		if !ins.result.is_first_run() { ins.result = test_result::ok; }
		return ();
	}
}

execute: (
	inout ins: testing_instance,
	executable_filepath: fs::path,
) -> bool = {
	test_exe_output_fn :== "03-executable.output";
	test_exe_output_filepath: const = ins.output_dir* / test_exe_output_fn;

	cmd_result := launch_program(
		ins.work_dir,
		executable_filepath,
		: std::vector<std::string> = (),
	);

	if !cmd_result.output.empty() {
		(: std::ofstream = (test_exe_output_filepath)) << cmd_result.output;
	}

	if ins.result.is_first_run() { return true; }

	if !cmd_result.output.empty() {
		assert(ins.output_dir* != ins.result_dir);

		if (ins.result_dir / test_exe_output_fn).read_file() !=
		                test_exe_output_filepath.read_file() {
			ins.result = test_result::test_exe_output_mismatch;
			return false;
		}
	} else {
		if test_exe_output_filepath.exists() {
			ins.result = test_result::test_exe_output_exists_when_it_shouldnt;
			return false;
		}
	}

	return true;
}

replace_all: (
	inout subject: std::string,
	search: std::string_view,
	replacement: std::string_view,
) = {
	pos: std::string::size_type = 0;
	while (pos = subject.find(search, pos)) != std::string::npos {
		_ = subject.replace(pos, search.size(), replacement);
		pos += replacement.size();
	}
}

read_file: (fp: fs::path) -> std::string = {
	out: std::string = ();
	b: std::array<char, 4096> = (); // TODO: Find a way to avoid this init?
	bd := b.data();
	f: std::ifstream = (fp, std::ios::in | std::ios::binary);
	while f.read(bd, b.size()) { _ = out.append(bd, 0, f.gcount()); }
	return out;
}

cpp2: namespace = { // TODO: remove later

to_string: (p: fs::path) -> std::string = {
	return p.string();
}

to_string: (vsv: std::vector<std::string_view>) -> std::string = {
	ret: std::string = "size==(vsv.size())$ content=>(";
	for vsv do (sv) _ = ret.append(sv).append(", ");
	_ = ret.append(")");
	return ret;
}

to_string: (vs: std::vector<std::string>) -> std::string = {
	ret: std::string = "size==(vs.size())$ content=>(";
	for vs do (s) _ = ret.append(s).append(", ");
	_ = ret.append(")");
	return ret;
}

}
